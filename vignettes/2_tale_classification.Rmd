---
title: "Classifying TALE sequences from genomes with tantale"
output: 
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>>")
```

```{r render, include=FALSE, eval = FALSE}
rmarkdown::render(input = "/home/cunnac/Lab-Related/MyScripts/tantale/vignettes/2_tale_classification.Rmd")

pkgdown::build_site(pkg = "/home/cunnac/Lab-Related/MyScripts/tantale",
                    lazy = FALSE,
                    )

pkgdown::build_article(pkg = "/home/cunnac/Lab-Related/MyScripts/tantale",
                    name = "2_tale_classification",
                    quiet = FALSE
                    )


```



```{r package, warning=FALSE, message=FALSE}
library(tantale)
library(ggplot2)
library(tidyverse)
library(Biostrings)
library(parallel)
library(magrittr)
library(DT)
library(gplots)
library(ape)
library(ggtree)
library(corrr)
library(ggcorrplot)
```

Based on the results of the article "Mining TALE sequences in genomes with tantale", this article will cover steps downstream of tal loci prediction. It will illustrate TALE classification, TALE multiple alignments and TALE target predictions with functions in package `tantale`.\
As a reminder, the genomes used for this article are MAI1, BAI3, BAI3-1-1 (an error-prone genome with TalC deleted) and PXO86, an outgroup Asian strain.\


```{r load previous session}
outdir <- fs::dir_create("~/TEMP/test_tantale") # tempdir(check = TRUE)
load(file.path(outdir, "mining.RData"))
```


# Classify the various TALE sequences into groups of related sequences

To classify TALE groups, we use the function `runDistal()` to run the tool DisTal that outputs similarity between TALEs and similarity between repeats. The TALE similarity table can be taken as input of `groupTales()` for clustering groups, and the repeats similarity can be used for plotting multiple alignment of Tals within group.

## Run DisTal

We run DisTal for all the putative TALE ORFs (from `telltale` output).

```{r distal_io, warning=FALSE}
distal_telltale <- file.path(outdir, "distal")
unlink(distal_telltale, recursive = TRUE)
dir.create(distal_telltale, showWarnings = F)
telltale_cds <- file.path(distal_telltale, "cds.fasta")
unlink(telltale_cds)


distal_telltale_input <- list.files(telltale_outdir,
                                    "putativeTalOrf.fasta",
                                    recursive = T, full.names = T)
distal_telltale_input <- distal_telltale_input[!grepl("ROI", distal_telltale_input, fixed = T)]
for (input in distal_telltale_input) {
  ttRunId <- gsub("\\_.+", "", basename(dirname(input)))
  seqs <- readBStringSet(input, seek.first.rec = T)
  names(seqs) <- paste0(ttRunId, "_", names(seqs))
  seqs <- seqs[width(seqs) != 0]
  #cat(names(seqs))
  writeXStringSet(seqs, telltale_cds, append = T)
}

# run DisTal
system.time({
  distal_output <- runDistal(telltale_cds, outdir = distal_telltale, overwrite = T)
})

```

## run the R implementation of DisTal

First we use the tellTale output directories for each genome and get the information about TALE parts (ie domains). The final output is a tibble with a single part per row.

```{r get tale parts, fig.width = 10, fig.height=10}
# distalrOutDir <- file.path(outdir, "distalr")
# unlink(distalrOutDir, recursive = TRUE)
# dir.create(distalrOutDir, showWarnings = F)


taleParts <- lapply(list.dirs(telltale_outdir, recursive = FALSE), function(ttGenomeDir) {
  genomeId <- gsub("_.*correction", "", basename(ttGenomeDir))
  logger::log_debug("Current genome: {genomeId}")
  taleParts <- getTaleParts(ttGenomeDir) %>%
    mutate(arrayID = paste0(genomeId, "_", arrayID))
  return(taleParts)
}) %>%
  bind_rows()

DT::datatable(head(taleParts), caption = "An example of the content of the taleParts tibble.")


```

With this kind of representation it is quite easy to make summary plots like this one for example:


```{r Overview of TALE composition by genome, fig.width = 10, fig.height=10}
partsForPlots <- taleParts %>%
  mutate(label = if_else(domainType == "repeat", rvd, ""),
         aaSeqLength = factor(nchar(aaSeq))
  )
partsForPlots %>% ggplot(mapping = aes(fill = aaSeqLength,
                                       color = domainType,
                                       label = label,
                                       y = arrayID,
                                       x = positionInArray),
                         color = isNaAaSeq) +
  scale_color_viridis_d(option = "rocket") +
  scale_fill_discrete() +
  scale_x_continuous(breaks = 1:50, minor_breaks = NULL) +
  geom_point(shape = 21, size = 5, stroke = 0.9) +
  ggnewscale::new_scale_color() +
  ggnewscale::new_scale_fill() +
  geom_text(size = 2.1, color = "white") + 
  facet_grid(seqnames~ ., scales = "free_y", space = "free") +
  labs(title = "Overview of TALE composition by genome") +
  theme_light()
```

Now, with this object, we can also run the R implementation of the Distal Perl code.


```{r doing the same with distalr, fig.width = 10, fig.height=10}
partsForDistalr <- taleParts

# distalr_mms_output <- distalr(taleParts = partsForDistalr,
#                               repeats.cluster.h.cut = 10, ncores = 6,
#                               pairwiseAlnMethod = "mmseq2",
#                               condaBinPath = "/home/cunnac/bin/miniconda3/condabin/conda")
system.time({distalr_deci_output <- distalr(taleParts = partsForDistalr,
                              repeats.cluster.h.cut = 10, ncores = 6,
                              pairwiseAlnMethod = "DECIPHER")})


system.time({distalr_bs_output <- distalr(taleParts = partsForDistalr,
                             repeats.cluster.h.cut = 10, ncores = 6,
                             pairwiseAlnMethod = "Biostrings")})



```

Clearly, the "DECIPHER" method for pairwise alignment of domains aa sequences is much faster than all the others.



## Contrast the output of the various distal functions


Now, we can take a look at whether the results of the original Distal script are consistent with our R implementation of the program.


```{r correlation of TALE similarity from various distal implementations, fig.width = 4, fig.height=4}
talSimOutAgregated <- list(distalALV = distal_output$tal.similarity,
     distalDECI = distalr_deci_output$tal.similarity,
     distalBIOS = distalr_bs_output$tal.similarity
) %>% bind_rows(.id = "method")

talSimOutAgregatedLong <- reshape2::dcast(talSimOutAgregated %>% select(method, TAL1, TAL2, Sim),
                                          formula = method ~ TAL1 + TAL2, value.var = "Sim"
                                            )
rownames(talSimOutAgregatedLong) <- talSimOutAgregatedLong$method
talSimOutAgregatedLong$method <- NULL
talSimOutAgregatedLong %<>% as.matrix() %>% t()
rownames(talSimOutAgregatedLong) <- NULL

corr_matrix <- cor(talSimOutAgregatedLong)
knitr::kable(corr_matrix)
ggcorrplot(corr_matrix)


talSimOutAgregated <- reshape2::dcast(talSimOutAgregated %>% select(method, TAL1, TAL2, Sim),
                                          formula = TAL1 + TAL2 ~ method, value.var = "Sim"
                                            ) %>% as_tibble()
```


```{r pair plot of TALE similarity from various distal implementations, fig.width = 4, fig.height=4}
# talSimOutAgregated %>%
#   select(-distalBIOS) %>%
#   mutate(pointLab = paste(TAL1, TAL2, sep = "|")) %>%
#   ggplot(mapping = aes(x = distalALV, distalDECI)) +
#   geom_point() +
#   geom_abline(intercept = 0, slope = 1)

pairs(talSimOutAgregated[3:5], pch = 20, cex = 0.5, lower.panel = NULL)
```



The correlation of the TALE pairwise similarity scores output by the various distal flavors are remarkably high.

## Allocate TALEs to groups of related sequences

```{r tale trees, fig.width = 6, fig.height=6}
k <- 22
groupsALV <- invisible(groupTales(taleSim = distal_output$tal.similarity,
                     plotTree = TRUE, k = k, k_test = 10:40,
                     method = "k-medoids"))

groupsDECI <- invisible(groupTales(taleSim = distalr_deci_output$tal.similarity,
                     plotTree = TRUE, k = k, k_test = 10:40,
                     method = "k-medoids"))

groupsBIOS <- invisible(groupTales(taleSim = distalr_bs_output$tal.similarity,
                     plotTree = TRUE, k = k, k_test = 10:40,
                     method = "k-medoids"))



grp <- groupTales(taleSim = distal_output$tal.similarity,
                     plotTree = TRUE, k = k,
                     method = "hclust")
grp <- groupTales(taleSim = distalr_deci_output$tal.similarity,
                     plotTree = TRUE, k = k,
                     method = "hclust")
grp <- groupTales(taleSim = distalr_bs_output$tal.similarity,
                     plotTree = TRUE, k = k,
                     method = "hclust")



getTALEsTree <- function(taleSim) {
  distMat <- 100 - reshape2::acast(taleSim, formula = TAL1 ~ TAL2, value.var = "Sim")
  hclust(dist(distMat, method = "euclidean"), method = "ward.D")
}

```

We can compare the hierarchical trees obtained with the original Distal tree (left) and distalr with DICEPHER (right). Because PXO86 is the only Asian strain and these TALEs are rather distantly related to African ones, the part of the trees with PXO86 TALEs are not really meaningfull in this context.


```{r tale trees comparisons, fig.width = 8, fig.height=8}
op <- par()
suppressWarnings(par(cex = 0.5))
ape::cophyloplot(getTALEsTree(distal_output$tal.similarity) %>% as.phylo(),
                 getTALEsTree(distalr_deci_output$tal.similarity) %>% as.phylo(),
                 assoc = matrix(rep(distal_output$tal.similarity$TAL1 %>% unique() %>% as.character(), 2),
                                ncol = 2, byrow = FALSE),
                 length.line = 0, space=200, gap = 10,
                 col = "red")
suppressWarnings(par(op))
```


```{r test_tale_group, fig.width = 6, fig.height=4}
taleGroups <- groupsDECI %>% as_tibble() %>% arrange(group, name)
knitr::kable(head(taleGroups, n= 12))
```

Based on the silhouette values, `groupTales()` will take the value at the elbow of the curve. In this case we manually took k = `r k``.


# TALE domains multiple alignments with similarity

If interested in performing TALEs multiple alignments (distal domains or RVDs) it makes sense to align TALEs that are related and that thus belong to the same group. This is what we are doing here but keep in mind that the `buildRepeatMsa()` function can take any arbitrary set of repeatID sequences or RVD sequences.

But right now what we need is a mapping between distal parts IDs and the cognate RVDs. This can be done in a number of ways but let's use the one below.

```{r fetching the necessary info about rvds}

rvdSeqs_fasta <- list.files(telltale_outdir, "rvdSequences.fas", recursive = T, full.names = T)
telltale_rvd <- file.path(distal_telltale, "rvd.fasta")
unlink(telltale_rvd)

# rename of RVD sequences to distinguish sequences between different strains
for (input in rvdSeqs_fasta) {
  id <- gsub("\\_.+", "", basename(dirname(input)))
  seqs <- readBStringSet(input, seek.first.rec = T)
  names(seqs) <- paste0(id, "_", names(seqs))
  names(seqs) <- stringr::str_trim(names(seqs))
  seqs <- seqs[width(seqs) != 0]
  writeXStringSet(seqs, telltale_rvd, append = T)
}

rvdVectors <- toListOfSplitedStr(telltale_rvd, sep = "-")
repeatVectors <- toListOfSplitedStr(distalr_deci_output$coded.repeats.str, sep = " ")

# map repeatID to RVD
rep2rvd <- getRepeat2RvdMapping(talesRepeatVectors = repeatVectors, talesRvdVectors = rvdVectors)
datatable(rep2rvd, options = list(pageLength = 5))
```




## Performing MSA using repeat strings

If possible it is more appropriate to align repeat/domains rather than RVD. For mafft (the underlying aligner), in our hands, the combo of gap opening score = 0 (`--op 0`) and gap extending score = 5 (`--ep 5`) (the current default values) yields better alignments.


```{r msa_with_sim, results = FALSE, eval= FALSE}
repeatVectors <- distalr_deci_output$coded.repeats.str
repeatSim <- distalr_deci_output$repeat.similarity #distal_output$repeat.similarity


lapply(sort(unique(taleGroups$group)), function(G) {repeatVectors[taleGroups$name[taleGroups$group == G]]})

repeatMsaByGroup_withSim <- lapply(sort(unique(taleGroups$group)), function(G) {
  try({buildRepeatMsa(inputSeqs = repeatVectors[taleGroups$name[taleGroups$group == G]],
                      sep = " ",
                      distalRepeatSims = repeatSim,
                      mafftOpts = "--globalpair --weighti 1 --maxiterate 1000 --reorder --op 0 --ep 5 --thread 1")
  })
}
)
```



## Plotting MSA with RVDs as text and  and coloring based on repeat similarity

For this type of plot, we need to map repeatID to RVD with `getRepeat2RvdMapping()`, then convert repeat MSA to RVD MSA by `convertRepeat2RvdAlign`. We should use the converting function rather than using `buildRepeatMsa()` to creat MSA of RVD because there will be disagreement between them.

```{r repeat.similarity_plot, fig.width = 12, fig.height = 4, eval= FALSE}
# convert repeat MSA to RVD MSA
repeatMSA <- repeatMsaByGroup_withSim[[2]]
rvdMSA <-  convertRepeat2RvdAlign(repeatAlign = repeatMSA, repeat2RvdMapping = rep2rvd)

# plot MSA
tantale::heatmap_msa(talsim = distalr_deci_output$tal.similarity,
                     repeatAlign = repeatMSA,
                     repeatSim = distalr_deci_output$repeat.similarity,
                     rvdAlign = rvdMSA,
                     plot.type = "repeat.similarity",
                     main = "Repeat MSA with similarity - Group 2")
```


## Plotting MSA with repeat Ids as text and coloring based on repeat clustering


```{r repeat.clusters_plot, fig.width = 12, fig.height = 4, eval= FALSE}
tantale::heatmap_msa(talsim = distalr_deci_output$tal.similarity,
                     repeatAlign = repeatMSA,
                     repeatSim = distalr_deci_output$repeat.similarity,
                     plot.type = "repeat.clusters",
                     main = "Repeat Cluster MSA - Group 2")
```


## Plotting MSA with RVD as text and coloring based on repeat clustering

For this plot, we also use the RVD MSA converted from repeat MSA.

```{r repeat.clusters.with.rvd_plot, fig.width = 12, fig.height = 4, eval= FALSE}
tantale::heatmap_msa(talsim = distalr_deci_output$tal.similarity,
                     repeatAlign = repeatMSA,
                     repeatSim = distalr_deci_output$repeat.similarity,
                     rvdAlign = rvdMSA,
                     plot.type = "repeat.clusters.with.rvd",
                     main = "Repeat Cluster MSA with RVD - Group 2",
                     consensusSeq = TRUE)
```

# Generate an overview of talomes

With the TALE classification result and RVD sequences, we can represent RVD sequence variants of all the strains for each TALE group as an example below.

```{r talomes_overview, fig.width = 10, fig.height = 6}
tale_annotation <- merge(taleGroups, 
                         data.frame("name" = names(rvdVectors),
                                    "rvdseq" = sapply(rvdVectors,
                                                      function(i) paste(i, collapse = "-")
                                                      ), stringsAsFactors = FALSE
                                    )
                         )
tale_annotation$strain <- gsub("\\_.+", "", tale_annotation$name)

heatmap_talomes(tale_annotation,
                col = "group", row = "strain",
                value = "rvdseq",
                mapcol = sunset10)
```

# TALE Target prediction

We wrap Talvez and Preditale tools in 2 functions, `talvez()` and `preditale()`, that take the same types of RVD sequences and promoter DNA sequences as inputs and output a data frame containing predictions.

We need to concatenate all RVD sequences from 3 `telltale` outputs and remove NTERM and CTERM markers.

```{r predict_input}
## rvd sequences from telltale output
rvdSeqs_tt <-  readBStringSet(telltale_rvd)
rvdSeqs_tt <- gsub("\\-{0,1}\\w{5}\\-{0,1}", "",rvdSeqs_tt) %>% BStringSet() # remove NTERM and CTERM
predict_input <- file.path(outdir, "rvd_to_predict.fasta")
writeXStringSet(rvdSeqs_tt, predict_input)


## promoter sequences
rvdSeqsXstrings <-  predict_input
subjDnaSeqFile <-  system.file("extdata", "cladeIII_sweet_promoters.fasta", package = "tantale", mustWork = T)
readBStringSet(subjDnaSeqFile) %>% names
```

## talvez

The output of `talvez()` contains the position, score and rank of each prediction.

```{r talvez, eval = TRUE}
talvezPreds <- talvez(rvdSeqs = rvdSeqsXstrings,
                      subjDnaSeqFile = subjDnaSeqFile,
                      optParam = "-t 0 -l 19",
                      condaBinPath = "/home/cunnac/bin/miniconda3/condabin/conda")
datatable(talvezPreds, options = list(pageLength = 1))
```

Here is an example of summarizing prediction result with `heatmap.2()` (scores are display by color scale, black refers no prediction):

```{r talvez_predict, fig.width = 6, fig.height = 8}
talvezPreds$strain <- gsub("\\_.+", "", talvezPreds$taleId)
talvezPreds$group <- sapply(talvezPreds$taleId, function(id) {
  ifelse(id %in% taleGroups$name, taleGroups$group[taleGroups$name == id], NA)
}, USE.NAMES = F)

slctPromoters <- c("SWEET14p_Nipponbare_Sense", "SWEET13p_Nipponbare_Sense", "SWEET11p_Nipponbare_Sense")
selectedPreds <- talvezPreds %>%
  dplyr::filter(subjSeqId %in% slctPromoters) 

selectedPredsMat <- selectedPreds %>%
  reshape2::acast(taleId ~ subjSeqId, max, na.rm = TRUE, value.var = "score", fill = as.single(NA))

heatmap.2(selectedPredsMat,
                  col = viridis::viridis(20), #cm.colors(255),
                  sepwidth=c(0.02,0.02), sepcolor="white", colsep = 1:ncol(selectedPredsMat), rowsep = 1:nrow(selectedPredsMat),
                  trace="none",
                  margins = c(10, 15),
                  cexRow = 1,
                  cexCol = 1, srtCol = 40,
                  density.info= "histogram", key.xlab = "Pred. Score", key.title = NA,
                  lwid = c(1,5), lhei = c(1,5),
                  dendrogram = "none", Rowv = NULL, Colv = NULL,
                  na.color = "black",
                  main = "Talvez prediction"
                  )
```

To see how RVD sequences match a promoter region, we supply the prediction table and the promoter sequence with the genomic range to `plotTaleTargetPred()`:

```{r SWEET13, fig.width = 14, fig.height = 4}
grFilter <- "SWEET14p_Nipponbare_Sense:340-450"
plotTaleTargetPred(predResults = selectedPreds, subjDnaSeqFile = subjDnaSeqFile, filterRange = grFilter)
```




## preditale

With Preditale, we get similar data frame output but with p value additionally. Preditale takes a little bit longer than Talvez and may give some different predictions.

```{r preditale, eval = TRUE}
preditalePreds <- preditale(rvdSeqs = rvdSeqsXstrings, subjDnaSeqFile = subjDnaSeqFile, outDir = NULL)
datatable(preditalePreds, options = list(pageLength = 1))
```

```{r preditale_predict, fig.width = 6, fig.height = 6}
talvezPreds$strain <- gsub("\\_.+", "", talvezPreds$taleId)
talvezPreds$group <- sapply(talvezPreds$taleId, function(id) {
  ifelse(id %in% taleGroups$name, taleGroups$group[taleGroups$name == id], NA)
}, USE.NAMES = F)

slctPromoters <- c("SWEET14p_Nipponbare_Sense", "SWEET13p_Nipponbare_Sense", "SWEET11p_Nipponbare_Sense")
selectedPreds <- preditalePreds %>%
  dplyr::filter(subjSeqId %in% slctPromoters) 

selectedPredsMat <- selectedPreds %>%
  reshape2::acast(taleId ~ subjSeqId, max, na.rm = TRUE, value.var = "score", fill = as.single(NA))

gplots::heatmap.2(selectedPredsMat,
                  col = viridis::viridis(20), #cm.colors(255),
                  sepwidth=c(0.02,0.02), sepcolor="white", colsep = 1:ncol(selectedPredsMat), rowsep = 1:nrow(selectedPredsMat),
                  trace="none",
                  margins = c(10, 15),
                  cexRow = 1,
                  cexCol = 1, srtCol = 40,
                  density.info= "histogram", key.xlab = "Pred. Score", key.title = NA,
                  lwid = c(1,5), lhei = c(1,5),
                  dendrogram = "none", Rowv = NULL, Colv = NULL,
                  na.color = "black",
                  main = "Preditale prediction"
                  )
```

```{r SWEET14, fig.width = 14, fig.height = 4}
grFilter <- "SWEET14p_Nipponbare_Sense:340-450"
plotTaleTargetPred(predResults = selectedPreds, subjDnaSeqFile = subjDnaSeqFile, filterRange = grFilter)
```

# Session info

```{r session info}
sessioninfo::session_info()
```

