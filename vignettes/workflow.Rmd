---
title: "Working with tantale"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>>")
```

```{r package, warning=FALSE, message=FALSE}
library(tantale)
library(ggplot2)
library(tidyverse)
library(Biostrings)
library(parallel)
library(magrittr)
library(DT)
library(gplots)
```

This vignette will go through all steps in a talomes analysis pipeline from Xoo genome sequences using functions in package `tantale`.\
Genomes used for this vignette are MAI1, BAI3, and BAI3-1-1 (an error-prone genome with TalC deleted).\

Get the fasta files:

```{r fasta_files}
mai1_fa <- system.file("extdata", "MAI1.fa", package = "tantale", mustWork = T)
bai3_fa <- system.file("extdata", "BAI3.fa", package = "tantale", mustWork = T)
bai311_fa <- system.file("extdata", "BAI3-1-1.fa", package = "tantale", mustWork = T)
```

Output dir to save all the results of this vignette:

```{r outdir}
outdir <- tempdir(check = TRUE) #"/tmp/test_tantale"
telltale2_outdir <- file.path(outdir, "telltale2")
dir.create(telltale2_outdir, showWarnings = T)
```

# find TALs

We will run `telltale2()` without correction for "gold" genomes, MAI1 and BAI3, and `telltale2()` with correction for "error-prone" genome BAI3-1-1.\
By default, `telltale2()` adds NTERM and CTERM to RVD sequences as markers of the termini, that is important to map the repeat codes by DisTal with the RVDs.

## run telltale2 no correction

```{r telltale_no_correction, eval=TRUE}
mclapply(c(mai1_fa, bai3_fa), function(fastaFile) {
  outdirname <- gsub(".fa", "_nocorrection", basename(fastaFile))
  outputDir <- file.path(telltale2_outdir, outdirname)
  tellTale(subjectFile = fastaFile,
            outputDir = outputDir,
            appendExtremityCodes = TRUE,
            rvdSep = "-",
            talArrayCorrection = FALSE)
}, mc.cores = 2) 
```

## run telltale2 correction

```{r telltale2_correction, eval=TRUE}
tellTale(subjectFile = bai311_fa,
          outputDir = file.path(telltale2_outdir, gsub(".fa", "_correction", basename(bai311_fa))),
          appendExtremityCodes = TRUE,
          rvdSep = "-",
          talArrayCorrection = TRUE)
```

## overview of telltale2 results

Besides RVD sequences and Tal ORFs, other useful outputs of `telltale2()` are the reports, from which we can get information about the structure of Tal sequences, corrections have been made, and so on.

The first we should take a look is "arrayReport.tsv".Wwe will take the files from 3 result folders, gather them, and see which information we can display from it.

```{r overview_arrayRport}
# color set for ploting
sunset10 <- c("#ba6b57", "#87556f", "#848ccf", "#93b5e1", "#6f4a8e", "#a2738c", "#ab93c9", "#588da8", "#726a95", "#bc658d")

arrayReport_files <- list.files(telltale2_outdir, "arrayReport.tsv", recursive = T, full.names = T)

arrayRp <- tibble()
for (f in arrayReport_files) {
  a <- read_tsv(f)
  if (!any(c("predicted_ins_count", "predicted_dels_count") %in% colnames(a)))
    # 2 columns "predicted_ins_count" and "predicted_dels_count" are not displayed in the report in case of no correction
    {a[c("predicted_ins_count", "predicted_dels_count")] <- NA} 
  a$strain <- gsub("\\_.+", "", basename(dirname(f)))
  arrayRp <- rbind(arrayRp, a)
}
arrayRp <- as_tibble(arrayRp)
```

This report takes result of HMMer for Tals motif detection, result of correction and AnnoTALE analyze.\
What information it contains:

```{r content_arrayRport}
colnames(arrayRp)
```

Some important points:

| Column name            | Content                                                          |
|-------------------|-----------------------------------------------------|
| `AllDomains`           | TRUE/FALSE, whether all the 3 domains of Tal arrays are detected |
| `aberrantRepeat`       | TRUE/FALSE, whether there is any aberrant repeat                 |
| `predicted_ins_count`  | number of insertions corrected by `telltale2()`                  |
| `predicted_dels_count` | number of deletions corrected by `telltale2()`                   |

### count AllDomains and aberrantRepeat

```{r AllDomains and aberrantRepeat, fig.width = 6, fig.height=4}
ggplot(arrayRp) +
  geom_bar(aes(x = strain, fill = AllDomains, color = aberrantRepeat), stat = "count") +
  scale_fill_manual(values = c("grey", sunset10[4])) +
  scale_color_manual(values = c("black", "red"), na.value = NA, labels = c("FALSE", "TRUE", "AnnoTALE_failed")) +
  guides(color = guide_legend(override.aes = list(fill = sunset10[4])))
```

### count corrections

total correction count per genome (in this case, there is only 1 genome that has been corrected)

```{r correction count per genome 2, fig.width = 6, fig.height=6}
arrayRp_correction <- reshape2::melt(arrayRp[c("strain", "arrayID", "predicted_ins_count", "predicted_dels_count")], value.name = "count", variable.name = "type")
arrayRp_correction %<>% dplyr::arrange(strain, arrayID)

ggplot(arrayRp_correction) +
  facet_wrap(vars(type), nrow = 2, scales = "fixed") +
  geom_bar(aes(x = strain, fill = factor(count))) +
  scale_fill_viridis_d() +
  guides(fill = guide_legend(title = "correction count"))
```

correction count per array per genome

```{r count per array per genome, fig.width = 6, fig.height=4}
ggplot(na.omit(arrayRp_correction), aes(x = arrayID, y = count, color = type, shape = type)) +
  facet_wrap(vars(strain), nrow = 2) +
  scale_shape_manual(values = c(20, 2)) +
  geom_point(size = 4) +
  scale_color_manual(values = c(sunset10[4], "black"))+
  theme(axis.text.x = element_text(angle = 90),
        legend.direction = "horizontal", legend.position = "bottom")
```

correction distribution per genome

```{r correction distribution, fig.width = 6, fig.height=4}
ggplot(na.omit(arrayRp_correction), aes(x = strain, y = count)) +
  geom_dotplot(aes(fill = type, color = type), binaxis = "y", stackdir = "center", position = "dodge", binwidth = 1/10) +
  scale_fill_manual(values = c(sunset10[4], "black")) +
  scale_color_manual(values = c(sunset10[4], "black")) +
  theme(legend.direction = "horizontal", legend.position = "bottom",
        panel.grid.minor.y = element_blank())
```

### count domain codon

Another report that we can reveal is "hitsReport.tsv", which contains results of HMMer.

```{r codon_count_annotale_1}
hitsReport_files <- dir(telltale2_outdir, "hitsReport.tsv", recursive = T, full.names = T)

hitsReport <- data.frame()
for (f in hitsReport_files) {
  a <- read.table(f, sep = "\t", stringsAsFactors = F, header = T)
  a$strain <- gsub("\\_.+", "", basename(dirname(f)))
  hitsReport <- rbind(hitsReport, a)
}
hitsReport$query_name <- factor(hitsReport$query_name, levels = c("TALE_N-terminus_CDS_aligned_curated", "TALE_repeat_CDS_aligned_curated", "TALE_C-terminus_CDS_aligned_curated_long"), ordered = F)
```

information in the hitsReport

```{r codon_count_annotale_2}
colnames(hitsReport)
```

We could see the length distribution of each Tal protein domain (`query_name`) predicted by HMMer.

```{r codon_count_annotale_3, fig.width = 10, fig.height=6}
ggplot(hitsReport) +
  facet_wrap(vars(query_name), scales = "free", nrow = 1) +
  geom_bar(aes(x = factor(codon_count), fill = strain), stat = "count", position = position_dodge(preserve = "single")) +
  scale_fill_manual(values = sunset10) +
  scale_y_sqrt(breaks = c(0, 1, 5, 10, 15, 100, 200, 350))
```

It seems that BAI3-1-1 has 1 Tal truncated at C-terminus caused by artifactual indels. But this is just the "raw" result of Tal motif detection.

Now we have a look at "domainsReport.tsv", a similar report as "hitsReport.tsv" except that it contains the information of Tal domains predicted by AnnoTALE after correction, , so that we can make comparision and infer the impact of correction in the protein sequences.

```{r codon_count_hmm, fig.width = 10, fig.height=6}
domainsReport_file <- dir(telltale2_outdir, "domainsReport.tsv", recursive = T, full.names = T)

domainsReport <- data.frame()
for (f in domainsReport_file) {
  a <- read.table(f, sep = "\t", stringsAsFactors = F, header = T)
  a$strain <- gsub("\\_.+", "", basename(dirname(f)))
  domainsReport <- rbind(domainsReport, a)
}

domainsReport$query_name <- factor(domainsReport$query_name, levels = c("N-terminus", "repeat", "C-terminus"))
domainsReport$codon_count <- as.factor(domainsReport$codon_count)

ggplot(domainsReport) +
  facet_wrap(vars(query_name), scales = "free", nrow = 1) +
  geom_bar(aes(x = codon_count, fill = strain), stat = "count", position = position_dodge(preserve = "single")) +
  scale_fill_manual(values = sunset10) +
  scale_y_sqrt(breaks = c(0, 1, 5, 10, 15, 100, 200, 350))
```

Firstly, the domain detection of AnnoTALE is different from HMMer at some amino acids.\
Secondly, the truncated C-terminus of BAI3-1-1 (84 aa) has been corrected and has the same length as its counterparts.

# classify TAL groups

To classify Tal groups, we use function `runDistal()` to run the tool DisTal that outputs similarity between Tals and similarity between repeats, then the Tals similarity can be taken as input of `groupTales()` for clustering groups, and the repeats similarity can be used for plotting multiple alignment of Tals within group.

## run DisTal

We run DisTal for all the putative TAL ORFs (from `telltale2` output).

```{r distal_io, warning=FALSE}
distal_telltale <- file.path(outdir, "distal")
unlink(distal_telltale, recursive = TRUE)
dir.create(distal_telltale, showWarnings = F)
telltale2_cds <- file.path(distal_telltale, "cds.fasta")
unlink(telltale2_cds)


distal_telltale_input <- list.files(telltale2_outdir,
                                    "putativeTalOrf.fasta",
                                    recursive = T, full.names = T)
distal_telltale_input <- distal_telltale_input[!grepl("ROI", distal_telltale_input, fixed = T)]
for (input in distal_telltale_input) {
  ttRunId <- gsub("\\_.+", "", basename(dirname(input)))
  seqs <- readBStringSet(input, seek.first.rec = T)
  names(seqs) <- paste0(ttRunId, "_", names(seqs))
  seqs <- seqs[width(seqs) != 0]
  #cat(names(seqs))
  writeXStringSet(seqs, telltale2_cds, append = T)
}

# run DisTal
distal_output <- runDistal(telltale2_cds, outdir = distal_telltale, overwrite = F)
```

## run the R implementation of DisTal

```{r doing the same with distalr}
distalrOutDir <- file.path(outdir, "distalr")
unlink(distalrOutDir, recursive = TRUE)
dir.create(distalrOutDir, showWarnings = F)

# ttGenomeDir <- list.dirs(telltale2_outdir, recursive = FALSE)[3]
taleParts <- lapply(list.dirs(telltale2_outdir, recursive = FALSE), function(ttGenomeDir) {
  genomeId <- gsub("_.*correction", "", basename(ttGenomeDir))
  taleParts <- getTaleParts(ttGenomeDir) %>%
    mutate(arrayID = paste0(genomeId, "_", arrayID))
  return(taleParts)
}) %>%
  bind_rows()

partsForPlots <- taleParts
partsForPlots <- taleParts %>% mutate(isNaAaSeq = is.na(aaSeq))
partsForPlots %>% ggplot(mapping = aes(fill = domainType, y = arrayID, x = position), color = isNaAaSeq) +
  geom_point(shape = 21)

selectedArrays <- taleParts %>% pull(arrayID) %>% sample(6)
partsForDistalr <- taleParts %>% filter(arrayID %in% selectedArrays)

partsForDistalr <- taleParts %>% filter(grepl("MAI1", arrayID))

distalr_mms_output <- distalr(taleParts = partsForDistalr,
                              repeats.cluster.h.cut = 10, ncores = 6,
                              pairwiseAlnMethod = "mmseq2",condaBinPath = "/home/cunnac/bin/miniconda3/condabin/conda")

distalr_deci_output <- distalr(taleParts = partsForDistalr,
                              repeats.cluster.h.cut = 10, ncores = 6,
                              pairwiseAlnMethod = "DECIPHER")

distalr_bs_output <- distalr(taleParts = partsForDistalr,
                             repeats.cluster.h.cut = 10, ncores = 6,
                             pairwiseAlnMethod = "Biostrings")


```

## classify TAL groups

```{r test_tale_group, fig.width = 6, fig.height=4}
taleGroups <- groupTales(distal_output$tal.similar, k_test = 5:15, k = "auto")
```

Based on the silhoutte values, `groupTales()` will take the value at the elbow of the curve. In this case it picked k = 9, and it makes sense as we already know that the each of the gold genomes have 9 Tals.

### msa with similarity

We can make MSA of repeatID sequence or RVD sequence with the function `buildRepeatMsa()`, however it make more sense to align repeat than RVD. For mafft, the combo of gap opening score = 0 and gap extending score = 5 creates better alignment than default values.

```{r msa_with_sim, results=FALSE}
repeatVectors <- distal_output$coded.repeats.str
repeatSim <- distal_output$repeat.similarity
repeatMsaByGroup_withSim <- lapply(sort(unique(taleGroups$group)), function(G) {
  repeatVectorsForGroup <- repeatVectors[taleGroups$name[taleGroups$group == G]]
  if (length(repeatVectorsForGroup) < 2) {
    msa <- as.matrix(as.data.frame(repeatVectorsForGroup))
    msa <- matrix(msa, nrow = 1)
    rownames(msa) <- colnames(as.data.frame(repeatVectorsForGroup))
    colnames(msa) <- 1:length(msa)
    return(msa)
    next()
  }
  repeatMsa <- buildRepeatMsa(inputSeqs = repeatVectorsForGroup, distalRepeatSims = repeatSim, mafftOpts = "--globalpair --weighti 1 --maxiterate 1000 --reorder --op 0 --ep 5 --thread 8")
  }
)
```

#### msa of repeat similarity

For this type of plot, we need to map repeatID to RVD with `getRepeat2RvdMapping()`, then convert repeat MSA to RVD MSA by `convertRepeat2RvdAlign`. We should use the converting function rather than using `buildRepeatMsa()` to creat MSA of RVD because there will be disagreement between them.

```{r repeat.similarity_plot, fig.width = 12, fig.height = 4}
rvdSeqs_fasta <- list.files(telltale2_outdir, "rvdSequences.fas", recursive = T, full.names = T)

telltale2_rvd <- file.path(distal_telltale, "rvd.fasta")
unlink(telltale2_rvd)

# rename of RVD sequences to distinguish sequences between different strains
for (input in rvdSeqs_fasta) {
  id <- gsub("\\_.+", "", basename(dirname(input)))
  seqs <- readBStringSet(input, seek.first.rec = T)
  names(seqs) <- paste0(id, "_", names(seqs))
  names(seqs) <- stringr::str_trim(names(seqs))
  seqs <- seqs[width(seqs) != 0]
  writeXStringSet(seqs, telltale2_rvd, append = T)
}

rvdVectors <- readBStringSet(telltale2_rvd)
rvdVectors <- sapply(rvdVectors, function(r) strsplit(toString(r), split = "-"))
repeatVectors <- distal_output$coded.repeats.str

# map repeatID to RVD
rep2rvd <- getRepeat2RvdMapping(talesRepeatVectors = repeatVectors, talesRvdVectors = rvdVectors)
datatable(rep2rvd, options = list(pageLength = 5))

# convert repeat MSA to RVD MSA
repeatMSA <- repeatMsaByGroup_withSim[[3]]
rvdMSA <-  convertRepeat2RvdAlign(repeatAlign = repeatMSA, repeat2RvdMapping = rep2rvd)

# plot MSA
tantale::heatmap_msa(talsim = distal_output$tal.similarity, repeatAlign = repeatMSA, repeatSim = distal_output$repeat.similarity, rvdAlign = rvdMSA, plot.type = "repeat.similarity", main = "Repeat MSA with similarity - Group 3")
```

#### msa of repeat cluster ID

```{r repeat.clusters_plot, fig.width = 12, fig.height = 4}
tantale::heatmap_msa(talsim = distal_output$tal.similarity, repeatAlign = repeatMSA, repeatSim = distal_output$repeat.similarity, plot.type = "repeat.clusters", main = "Repeat Cluster MSA - Group 3")
```

#### msa of repeat ID with RVD labeled

For this plot, we also use the RVD MSA converted from repeat MSA.

```{r repeat.clusters.with.rvd_plot, fig.width = 12, fig.height = 4}
rvdMSA <-  convertRepeat2RvdAlign(repeatAlign = repeatMSA, repeat2RvdMapping = rep2rvd)
tantale::heatmap_msa(talsim = distal_output$tal.similarity, repeatAlign = repeatMSA, repeatSim = distal_output$repeat.similarity,  rvdAlign = rvdMSA, plot.type = "repeat.clusters.with.rvd", main = "Repeat Cluster MSA with RVD - Group 3", consensusSeq = TRUE)
```

# overview of talomes

With the Tal classification result and RVD sequences, we can represent RVD sequence variants of all the strains for each Tal group as an example below.

```{r talomes_overview, fig.width = 8, fig.height = 6}
tale_annotation <- merge(taleGroups, 
      data.frame("name" = names(rvdVectors), "rvdseq" = sapply(rvdVectors, function(i) paste(i, collapse = "-")), stringsAsFactors = FALSE))
tale_annotation$strain <- gsub("\\_.+", "", tale_annotation$name)

heatmap_talomes(tale_annotation, col = "group", row = "strain", value = "rvdseq", mapcol = sunset10)
```

# predict target

We wrap Talvez and Preditale tools in 2 functions, `talvez()` and `preditale()`, that take the same types of RVD sequences and promoter DNA sequences as inputs and output a data frame containing predictions.

We need to concatenate all RVD sequences from 3 `telltale2` outputs and remove NTERM and CTERM markers.

```{r predict_input}
## rvd sequences from telltale2 output
rvdSeqs_tt <-  readBStringSet(telltale2_rvd)
rvdSeqs_tt <- gsub("\\-{0,1}\\w{5}\\-{0,1}", "",rvdSeqs_tt) %>% BStringSet() # remove NTERM and CTERM
predict_input <- file.path(outdir, "rvd_to_predict.fasta")
writeXStringSet(rvdSeqs_tt, predict_input)


## promoter sequences
rvdSeqsXstrings <-  predict_input
subjDnaSeqFile <-  system.file("extdata", "cladeIII_sweet_promoters.fasta", package = "tantale", mustWork = T)
readBStringSet(subjDnaSeqFile) %>% names
```

## talvez

The output of `talvez()` contains the position, score and rank of each prediction.

```{r talvez, eval = TRUE}
talvezPreds <- talvez(rvdSeqs = rvdSeqsXstrings, subjDnaSeqFile = subjDnaSeqFile, optParam = "-t 0 -l 19")
datatable(talvezPreds, options = list(pageLength = 1))
```

Here is an example of summarizing prediction result with `heatmap.2()` (scores are display by color scale, black refers no prediction):

```{r talvez_predict, fig.width = 8, fig.height = 8}
talvezPreds$strain <- gsub("\\_.+", "", talvezPreds$taleId)
talvezPreds$group <- sapply(talvezPreds$taleId, function(id) {
  ifelse(id %in% taleGroups$name, taleGroups$group[taleGroups$name == id], NA)
}, USE.NAMES = F)

slctPromoters <- c("SWEET14p_Nipponbare_Sense", "SWEET13p_Nipponbare_Sense", "SWEET11p_Nipponbare_Sense")
selectedPreds <- talvezPreds %>%
  dplyr::filter(subjSeqId %in% slctPromoters) 

selectedPredsMat <- selectedPreds %>%
  reshape2::acast(taleId ~ subjSeqId, max, na.rm = TRUE, value.var = "score", fill = as.single(NA))

heatmap.2(selectedPredsMat,
                  col = viridis::viridis(20), #cm.colors(255),
                  sepwidth=c(0.02,0.02), sepcolor="white", colsep = 1:ncol(selectedPredsMat), rowsep = 1:nrow(selectedPredsMat),
                  trace="none",
                  margins = c(10, 15),
                  cexRow = 1,
                  cexCol = 1, srtCol = 40,
                  density.info= "histogram", key.xlab = "Pred. Score", key.title = NA,
                  lwid = c(1,5), lhei = c(1,5),
                  dendrogram = "none", Rowv = NULL, Colv = NULL,
                  na.color = "black",
                  main = "Talvez prediction"
                  )
```

To see how RVD sequences match a promoter region, we supply the prediction table and the promoter sequence with the genomic range to `plotTaleTargetPred()`:

```{r SWEET13, fig.width = 8, fig.height = 5}
grFilter <- "SWEET14p_Nipponbare_Sense:340-450"
plotTaleTargetPred(predResults = selectedPreds, subjDnaSeqFile = subjDnaSeqFile, filterRange = grFilter)
```

## preditale

With Preditale, we get similar data frame output but with p value additionally. Preditale takes a little bit longer than Talvez and may give some different predictions.

```{r preditale, eval = TRUE}
preditalePreds <- preditale(rvdSeqs = rvdSeqsXstrings, subjDnaSeqFile = subjDnaSeqFile, outDir = NULL)
datatable(preditalePreds, options = list(pageLength = 1))
```

```{r preditale_predict, fig.width = 8, fig.height = 8}
talvezPreds$strain <- gsub("\\_.+", "", talvezPreds$taleId)
talvezPreds$group <- sapply(talvezPreds$taleId, function(id) {
  ifelse(id %in% taleGroups$name, taleGroups$group[taleGroups$name == id], NA)
}, USE.NAMES = F)

slctPromoters <- c("SWEET14p_Nipponbare_Sense", "SWEET13p_Nipponbare_Sense", "SWEET11p_Nipponbare_Sense")
selectedPreds <- preditalePreds %>%
  dplyr::filter(subjSeqId %in% slctPromoters) 

selectedPredsMat <- selectedPreds %>%
  reshape2::acast(taleId ~ subjSeqId, max, na.rm = TRUE, value.var = "score", fill = as.single(NA))

gplots::heatmap.2(selectedPredsMat,
                  col = viridis::viridis(20), #cm.colors(255),
                  sepwidth=c(0.02,0.02), sepcolor="white", colsep = 1:ncol(selectedPredsMat), rowsep = 1:nrow(selectedPredsMat),
                  trace="none",
                  margins = c(10, 15),
                  cexRow = 1,
                  cexCol = 1, srtCol = 40,
                  density.info= "histogram", key.xlab = "Pred. Score", key.title = NA,
                  lwid = c(1,5), lhei = c(1,5),
                  dendrogram = "none", Rowv = NULL, Colv = NULL,
                  na.color = "black",
                  main = "Preditale prediction"
                  )
```

```{r SWEET14, fig.width = 8, fig.height = 4}
grFilter <- "SWEET14p_Nipponbare_Sense:340-450"
plotTaleTargetPred(predResults = selectedPreds, subjDnaSeqFile = subjDnaSeqFile, filterRange = grFilter)
```
