

##### General utilisty functions ####


pickRefName <- function(align, refTag = NULL) {
  # How do we select the reference TALE in an alignement?
  #   - the reference could be defined by name or by a string match in the name (eg a strain ID)
  #   - the reference could by default be defined as the longest tal and picked by
  #     ordering their names in case of ties...

  # Find refTag in seq names if provided and output the corresponding unique match
  if (! is.null(refTag)) {
    match <- grepl(refTag, rownames(align))
    if (sum(match) != 1) {
      warning("Cannot identify a single unambiguous sequence to define as a reference using the string in refTag.\n",
              "Using the default method for reference selection.")
      refTag <- NULL
    } else {
      refName <- rownames(align)[match]
    }
  }
  # If no refTag is provided, pick the longest seq(s) and if there are ties, pick the first one alphabetically
  if (is.null(refTag)) {
    strippedAlignLengths <- apply(align, 1, function(seq) length(seq[! is.na(seq)]))
    longest <- rownames(align)[strippedAlignLengths == max(strippedAlignLengths)]
    ifelse(length(longest) == 1, refName <- longest, refName <- sort(longest)[1])
  }
  return(refName)
}



convertRepeat2RvdAlign <-  function(repeatAlign , repeat2RvdMapping) {
  # A function to substitute repeatIDs and RVDs in the alignment matrix This
  # function take as input, the repeat alignment and  the tibble (?) prodcuded by
  # `getRepeat2RvdMapping()` This function output the modified alignment matrix

  states <- unique(as.vector(repeatAlign))
  rvdAlign <- t(
    apply(repeatAlign, 1,
          function(repeatSeq){
            rvdSeq <- repeat2RvdMapping$RVD[match(repeatSeq, repeat2RvdMapping$repeatID)]
          }
    )
  )
  rvdAlign <- matrix(rvdAlign, nrow = nrow(repeatAlign)) # in case of 1-row matrix
  rownames(rvdAlign) <- rownames(repeatAlign)
  colnames(rvdAlign) <- colnames(repeatAlign)
  return(rvdAlign)
}



convertRepeat2SimAlign <-  function(repeatAlign, repeatsims, refTag = NULL) {
  # A function that substitute the repeatIDs with the aa similarity relative to a
  # reference repeat for each column. The ref repeat is the one from a TALE that
  # is defined as a reference in the alignment. This function takes as input, the
  # repeat alignment and the df output by `formatDistalRepeatDistMat()` This
  # function outputs the modified alignment matrix

  refRowIdx <- match(pickRefName(repeatAlign, refTag = refTag), rownames(repeatAlign))
  simAlign <- apply(repeatAlign, 2,
                    function(column) {
                      refState <- column[refRowIdx]
                      relevantSims <- subset(repeatSim, subset = RepU1 == refState)
                      relevantSims$Sim[match(column, relevantSims$RepU2, nomatch = NA)]
                    }
  )
  simAlign <- matrix(simAlign, nrow = nrow(repeatAlign)) # in case of 1-row matrix
  rownames(simAlign) <- rownames(repeatAlign)
  colnames(simAlign) <- colnames(repeatAlign)
  return(simAlign)
}




convertRvd2MatchAlign <-  function(rvdAlign, rvdSims = tantale::rvdSimDf, refTag = NULL) {
  # A function that substitute the RVDs with a 'RVD match score' relative to a
  # reference rvd for each column. The ref repeat is the one from a TALE that is
  # defined as a reference in the alignment. This function take as input, the
  # repeat alignment and the tantale::rvdSimDf This function output the modified
  # alignment matrix
  refRowIdx <- match(pickRefName(rvdAlign, refTag = refTag), rownames(rvdAlign))
  simAlign <- apply(rvdAlign, 2,
                    function(column) {
                      refState <- column[refRowIdx]
                      relevantSims <- subset(rvdSims, subset = rvd1 == refState)
                      relevantSims$Cor[match(column, relevantSims$rvd2, nomatch = NA)]
                    }
  )
  simAlign <- matrix(simAlign, nrow = nrow(rvdAlign)) # in case of 1-row matrix
  rownames(simAlign) <- rownames(rvdAlign)
  colnames(simAlign) <- colnames(rvdAlign)
  return(simAlign)
}

convertRepeat2ClusterIDAlign <- function(repeatSim, repeatAlign, h.cut = 10) {
  repeatSim <-  as.matrix(reshape2::acast(repeatSim, RepU1 ~ RepU2, value.var="Sim"))
  dist_clust <- hclust(as.dist(repeatSim))
  dist_cut <- as.data.frame(cbind(RepID = dist_clust$labels, Rep_clust = cutree(dist_clust, h = h.cut)))
  clustIDAlign <- apply(repeatAlign, 2, 
                        function(column){
                          as.numeric(dist_cut$Rep_clust[match(column, dist_cut$RepID)])
                        })
  clustIDAlign <- matrix(clustIDAlign, nrow = nrow(repeatAlign)) # in case of 1-row matrix
  rownames(clustIDAlign) <- rownames(repeatAlign)
  colnames(clustIDAlign) <- colnames(repeatAlign)
  return(clustIDAlign)
}
