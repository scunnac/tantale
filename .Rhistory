Start = BiocGenerics::start(arraysGR),
End = BiocGenerics::end(arraysGR),
Strand = BiocGenerics::strand(arraysGR),
NumberOfHits = S4Vectors::elementNROWS(hitsByArraysLst),
SeqOfRVD =   stitchSeqs(hitsByArraysLst, "RVD", sep = rvdSep, onlyRepeats = !appendExtremityCodes),
ArraySeq = BSgenome::getSeq(subjectDNASequences, arraysGR),
CorrectedRepArrayDnaSeq = Biostrings::DNAStringSet(
stitchSeqs(hitsByArraysLst, "corrected_seq", sep = "", onlyRepeats = TRUE)
),
CorrectedRepArrayAaSeq = Biostrings::AAStringSet(
stitchSeqs(hitsByArraysLst, "corrected_AA_seq", sep = "", onlyRepeats = TRUE)
),
SelectedForAssembly = S4Vectors::elementNROWS(hitsByArraysLst) >= minDomainHitsPerArrayForAssembl,
AllDomains = sapply(hitsByArraysLst,
function(x) {
all(
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName) %in% x$query_name
)
}
)
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName)
sapply(hitsByArraysLst,
function(x) {
all(
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName) %in% x$query_name
)
}
)
S4Vectors::mcols(hitsByArraysLst) <- S4Vectors::DataFrame(
arrayID = names(hitsByArraysLst),
OriginalSubjectName = sapply(hitsByArraysLst,
function(x) unique(as.character(GenomicRanges::seqnames(x)))),
Start = BiocGenerics::start(arraysGR),
End = BiocGenerics::end(arraysGR),
Strand = BiocGenerics::strand(arraysGR),
NumberOfHits = S4Vectors::elementNROWS(hitsByArraysLst),
# SeqOfRVD =   stitchSeqs(hitsByArraysLst, "RVD", sep = rvdSep, onlyRepeats = !appendExtremityCodes),
ArraySeq = BSgenome::getSeq(subjectDNASequences, arraysGR),
AllDomains = sapply(hitsByArraysLst,
function(x) {
all(
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName) %in% x$query_name
)
}
)
S4Vectors::mcols(hitsByArraysLst) <- S4Vectors::DataFrame(
arrayID = names(hitsByArraysLst),
OriginalSubjectName = sapply(hitsByArraysLst,
function(x) unique(as.character(GenomicRanges::seqnames(x)))),
Start = BiocGenerics::start(arraysGR),
End = BiocGenerics::end(arraysGR),
Strand = BiocGenerics::strand(arraysGR),
NumberOfHits = S4Vectors::elementNROWS(hitsByArraysLst),
# SeqOfRVD =   stitchSeqs(hitsByArraysLst, "RVD", sep = rvdSep, onlyRepeats = !appendExtremityCodes),
ArraySeq = BSgenome::getSeq(subjectDNASequences, arraysGR),
# CorrectedRepArrayDnaSeq = Biostrings::DNAStringSet(
#   stitchSeqs(hitsByArraysLst, "corrected_seq", sep = "", onlyRepeats = TRUE)
# ),
# CorrectedRepArrayAaSeq = Biostrings::AAStringSet(
#   stitchSeqs(hitsByArraysLst, "corrected_AA_seq", sep = "", onlyRepeats = TRUE)
# ),
# SelectedForAssembly = S4Vectors::elementNROWS(hitsByArraysLst) >= minDomainHitsPerArrayForAssembl
AllDomains = sapply(hitsByArraysLst,
function(x) {
all(
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName) %in% x$query_name
)
}
)
# setwd("/home/baotram/tal/xanthopore-scripts/tantale")
devtools::load_all()
tantale::tellTale2(subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/PXO86.fa",
outputDir = pxo86_correct,
taleArrayStartAnchorCode = "N-TERM",
taleArrayEndAnchorCode = "C-TERM",
appendExtremityCodes = TRUE,
rvdSep = " ",
talArrayCorrection = TRUE,
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz",
frameShiftCorrection = -11)
S4Vectors::mcols(hitsByArraysLst) <- S4Vectors::DataFrame(
arrayID = names(hitsByArraysLst),
OriginalSubjectName = sapply(hitsByArraysLst,
function(x) unique(as.character(GenomicRanges::seqnames(x)))),
Start = BiocGenerics::start(arraysGR),
End = BiocGenerics::end(arraysGR),
Strand = BiocGenerics::strand(arraysGR),
NumberOfHits = S4Vectors::elementNROWS(hitsByArraysLst),
# SeqOfRVD =   stitchSeqs(hitsByArraysLst, "RVD", sep = rvdSep, onlyRepeats = !appendExtremityCodes),
ArraySeq = BSgenome::getSeq(subjectDNASequences, arraysGR),
# CorrectedRepArrayDnaSeq = Biostrings::DNAStringSet(
#   stitchSeqs(hitsByArraysLst, "corrected_seq", sep = "", onlyRepeats = TRUE)
# ),
# CorrectedRepArrayAaSeq = Biostrings::AAStringSet(
#   stitchSeqs(hitsByArraysLst, "corrected_AA_seq", sep = "", onlyRepeats = TRUE)
# ),
# SelectedForAssembly = S4Vectors::elementNROWS(hitsByArraysLst) >= minDomainHitsPerArrayForAssembl
AllDomains = sapply(hitsByArraysLst,
function(x) {
all(
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName) %in% x$query_name
)
}
)
# setwd("/home/baotram/tal/xanthopore-scripts/tantale")
devtools::load_all()
tantale::tellTale2(subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/PXO86.fa",
outputDir = pxo86_correct,
taleArrayStartAnchorCode = "N-TERM",
taleArrayEndAnchorCode = "C-TERM",
appendExtremityCodes = TRUE,
rvdSep = " ",
talArrayCorrection = TRUE,
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz",
frameShiftCorrection = -11)
sapply(hitsByArraysLst,
function(x) {
all(
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName) %in% x$query_name
)
}
)
S4Vectors::elementNROWS(hitsByArraysLst)
fullTalCds[sapply(names(fullTalCds), function(n) any(n %in% insertions_count$Seq, n %in% deletions_count$Seq))]
c(insertions_count$Seq, deletions_count$Seq)
fullTalCds[sapply(names(fullTalCds), function(n) any(n %in% c(insertions_count$Seq, deletions_count$Seq)))]
any(n %in% c(insertions_count$Seq, deletions_count$Seq))
any(n %in% insertions_count$Seq, n %in% deletions_count$Seq)
fullTalCds[sapply(names(fullTalCds), function(n) any(n %in% insertions_count$Seq, n %in% deletions_count$Seq))]
fullTalCds[sapply(names(fullTalCds), function(n) n %in% c(insertions_count$Seq, deletions_count$Seq))]
fullTalCds
rawArraySeq
outputDir
subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/BAI3.fa"
outputDir = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale2/bai3_correct"
hmmFilesDir = "/home/baotram/tal/xanthopore-scripts/tantale/inst/extdata/hmmProfile"
hmmerpath = "/home/baotram/tal/xanthopore-scripts/tantale/inst/tools/hmmer-3.3/bin/"
talArrayCorrection = TRUE
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz"
frameShiftCorrection = -11
minRatioOfGapForColMasking = 0.8
TALE_NtermDNAHitMinScore = 300
repeatDNAHitMinScore = 20
TALE_CtermDNAHitMinScore = 200
minDomainHitsPerSubjSeq = 4
mergeHits = TRUE
# repMsaMethod = "decipher"
minGapWidth = 35
minDomainHitsPerArrayForAssembl  = 5
taleArrayStartAnchorCode = "N-TERM"
taleArrayEndAnchorCode = "C-TERM"
appendExtremityCodes = TRUE
rvdSep = "-"
repeatDNASeqsFile <- file.path(outputDir, "hmmerRepeatHitsDNASeqs.fas")
## hmmerAlign alignment of repeat CDS
repeatsAlignOutFile <- file.path(outputDir, "repeatsAlignOut.txt")
## sequences of the 'corrected/cleaned' repeat CDS
correctedRepeatsAlignOutFile <- file.path(outputDir, "hmmerCleanedAlignOut.fas")
## sequences of the 'corrected/cleaned' repeat Translations after removing stop codon translations (*)
translatedCorrectedRepeatsAlignOutFile <- file.path(outputDir, "translatedCleanRepeatsAlignment.pep")
## output of hmmer search on the repeat AA sequences
repeatAaSearchOutFile <- file.path(outputDir, "hmmerAASearchOut.txt")
## hmmerAlign alignment of the repeat AA sequences
repeatsAaAlignOutFile <- file.path(outputDir, "hmmerAAAlignOut.txt")
## fasta file of central repeat domain "corrected" CDS for each array
correctedArrayDnaSeqsFile <- file.path(outputDir, "correctedRepeatDNASeqs.fas")
## fasta file of translation of products of central repeat domain "corrected" CDS for each array
correctedArrayAaSeqsFile <- file.path(outputDir, "correctedRepeatAASeqs.fas")
## Fasta (.pep) file where sequences of translated TALE N-Term CDS domains are written
fullNtermAAseqFile <- file.path(outputDir, "fullNtermAAseq.pep")
## Fasta (.pep) file where sequences of translated TALE C-Term CDS domains are written
fullCtermAAseqFile <- file.path(outputDir, "fullCtermAAseq.pep")
## Tabular file reporting on individual TALE domain hits
hitsReportFile <- file.path(outputDir, "hitsReport.tsv")
## Tabular file reporting on putative TALEs (contiguous arrays of domain hits)
arrayReportFile <- file.path(outputDir, "arrayReport.tsv")
## Gff file with all the identified domains and arrays and their associated data
affRangesGffFile <- file.path(outputDir, "allRanges.gff")
## A fasta file of the selected seq of RVDs without the - separator
seqsOfRVDFile <- file.path(outputDir, "rvdSequences.fas")
## A fasta file with array ORFs DNA sequences
arrayOrfsSeqFile <- file.path(outputDir, "arrayOrfs.fas")
## A text file where logging info and some general analysis measures are written
analysisLogFile <- file.path(outputDir, "tellTale.log")
#####   Checks for parameters and other things   #####
if (minDomainHitsPerSubjSeq > minDomainHitsPerArrayForAssembl) {
warning("The value of the minDomainHits parameter for subject sequence selection\n",
"is more stringent than the value of the minNumberOfDomainHitsForAssembly!?\n",
"Is this really what you want to do?")
}
## Deal with spaces in sequence names because this messes up parsing of HMMER output
originalSeqs <- Biostrings::readDNAStringSet(filepath = subjectFile)
originalSeqlevels <- names(originalSeqs)
foolproofSeqlevels <- paste0("seq", 1:length(originalSeqlevels))
names(originalSeqlevels) <- foolproofSeqlevels
names(originalSeqs) <- foolproofSeqlevels
subjectFile <- tempfile()
Biostrings::writeXStringSet(originalSeqs, filepath = subjectFile)
#####   Full paths of input HMM files for TALE domains (DNA and AA)   ####
## TODO come up with a mechanism for the user to be able to provide the FULL PATH
## to custom hmm !!! hmmFilesDir parameter is useless unless custom hmm are named
## as specified below
TALE_NtermDNAHMMFile <- file.path(hmmFilesDir, "Xo_TALE_Nterm_CDS_profile.hmm")
repeatDNAHMMFile <- file.path(hmmFilesDir, "Xo_TALE_repeat_CDS_profile.hmm")
TALE_CtermDNAHMMFile <- file.path(hmmFilesDir, "Xo_TALE_Cterm_CDS_profile.hmm")
repeatAAHMMFile <- file.path(hmmFilesDir, "Xo_TALE_repeat_AA_profile.hmm")
DNAHMMFiles <- c(TALE_NtermDNAHMMFile, repeatDNAHMMFile, TALE_CtermDNAHMMFile)
mergedDNAHMMFile <- file.path(outputDir, "TALE_CDS_all_diagnostic_regions_hmmfile.out")
#####   Concatenate HMM files for TALE DNA motifs and parse HMM names   #####
hmmslines <- plyr::llply(DNAHMMFiles, function(x) txt <- readLines(con = x))
names(DNAHMMFiles) <- plyr::llply(hmmslines, function(x) {
hmmName <- grep("NAME", x, perl = TRUE, value = TRUE)
hmmName <- unlist(strsplit(hmmName, split = "\\s+"))
if (length(hmmName) != 2) stop("One or several profile ",
"HMM have a name with with spaces. ",
"Please remove them in the file at the Tag 'NAME'")
hmmName <- hmmName[2]
}
)
DNAHMMNames <- names(DNAHMMFiles)
TALE_NtermDNAHMMName <- names(DNAHMMFiles)[1]
repeatDNAHMMName <- names(DNAHMMFiles)[2]
TALE_CtermDNAHMMName <- names(DNAHMMFiles)[3]
writeLines(text = unlist(hmmslines), con = mergedDNAHMMFile)
#####   Perform TALE domain CDS search with HMMER  #####
searchOutFile <- file.path(outputDir, "hmmerSearchOut.txt")
runNhmmerSearch(hmmerpath = hmmerpath,
subjectFile = subjectFile,
hmmFile = mergedDNAHMMFile,
searchTblOutFile = searchOutFile,
humReadableOutFile = file.path(outputDir, "nhmmerHumanReadableOutputOfLastRun.txt"))
#####   Load, process, filter TALE domain CDS HMMER hit results    #####
## Loading search tabular output file
nhmmerTabularOutput <- read.table(searchOutFile)
colnames(nhmmerTabularOutput) <- c("target_name", "accession", "query_name", "accession", "hmmfrom", "hmm_to", "alifrom",
"ali_to", "envfrom", "env_to", "sq_len", "strand", "Evalue", "score", "bias", "description_of_target")
## filtering results differentially depending on the query HMM
nhmmerTabularOutput <- subset(nhmmerTabularOutput,
query_name == TALE_NtermDNAHMMName & score >= TALE_NtermDNAHitMinScore |
query_name == repeatDNAHMMName & score >= repeatDNAHitMinScore |
query_name == TALE_CtermDNAHMMName & score >= TALE_CtermDNAHitMinScore
)
nhmmerTabularOutput <- droplevels(nhmmerTabularOutput)
## Add a hitID column
nhmmerTabularOutput$hitID <- paste("DOM", sprintf("%05.0f", 1:nrow(nhmmerTabularOutput)), sep="_")
## Trick to re-order positions in an increasing order to satisfy IRanges() in preparation of creating a GRanges
nhmmerTabularOutput[,c("start", "end")] <- plyr::adply(.data = nhmmerTabularOutput[,c("envfrom", "env_to")], .margins = 1, .fun = c(min, max))[,-(1:2)]
# nhmmerTabularOutput[,c("start", "end")] <- plyr::adply(.data = nhmmerTabularOutput[,c("alifrom", "ali_to")], .margins = 1, .fun = c(min, max))[,-(1:2)]
rownames(nhmmerTabularOutput) <- nhmmerTabularOutput$hitID
#####   Storing all info about individual TALE domains in a GenomicRanges object   ####
## Filter out target DNA sequences that have too few repeat CDSs
## NB: for the sake of consistency  it would be better just to filter out
## from any further consideration the ARRAYS shorter than a certain value (say 5).
## WHAT DO WE DO ABOUT THAT?
temp_df <- plyr::ddply(nhmmerTabularOutput[,-20], ~ target_name + sq_len, nrow) # I do not know why but it fails to work if I leave the RVD column (#20)
nhmmerTabularOutput <- subset(nhmmerTabularOutput, target_name %in% temp_df[temp_df$V1 > minDomainHitsPerSubjSeq, "target_name"])
nhmmerTabularOutput <- droplevels(nhmmerTabularOutput)
## Creating a GRanges object from nhmmerOutput
nhmmerOutputGR <- GenomicRanges::makeGRangesFromDataFrame(
df = nhmmerTabularOutput, keep.extra.columns = TRUE,
seqnames.field= "target_name"
)
names(nhmmerOutputGR) <- nhmmerOutputGR$hitID
GenomeInfoDb::seqinfo(nhmmerOutputGR) <- GenomeInfoDb::Seqinfo(
seqnames = as.character(temp_df$target_name),
seqlengths=temp_df$sq_len,
isCircular=NA,
genome=NA
)
GenomeInfoDb::seqlevels(nhmmerOutputGR) <- originalSeqlevels[match(GenomeInfoDb::seqlevels(nhmmerOutputGR), names(originalSeqlevels))]
nhmmerOutputGRBeforeMerge <- nhmmerOutputGR
#####   Domain-wise merge of overlapping hits  #####
if (mergeHits) {
## Split the ranges by domain type
nhmrOutGrByDomain <- GenomicRanges::split(nhmmerOutputGR, f = nhmmerOutputGR$query_name)
## Perform merge
reducedOlapGr <- lapply(nhmrOutGrByDomain, function(gr) {
reducedOlapGr <- as.data.frame(GenomicRanges::findOverlaps(gr, gr,
minoverlap = 2,
type = "any",
ignore.strand=FALSE,
select = "all")) %>%
dplyr::group_by(queryHits) %>%
dplyr::group_map({
~ GenomicRanges::reduce(gr[as.numeric(.x$subjectHits)], with.revmap = FALSE)
}) %>%
plyranges::bind_ranges() %>%
unique()
formerIDs <- as.data.frame(GenomicRanges::findOverlaps(gr, reducedOlapGr,
minoverlap = 2,
type = "within",
ignore.strand=FALSE,
select = "all")) %>%
dplyr::group_by(subjectHits) %>%
dplyr::group_map({
~ paste0(gr[as.numeric(.x$queryHits)]$hitID, collapse = "|")
}) %>%
unlist()
reducedOlapGr$nhmmerHitID <- formerIDs
return(reducedOlapGr)
}) %>%
plyranges::bind_ranges(.id = "query_name")
reducedOlapGr$hitID <- paste("MDOM", sprintf("%05.0f", 1:length(reducedOlapGr)), sep="_")
names(reducedOlapGr) <- reducedOlapGr$hitID
## From there on, use the merged hits GRanges
nhmmerOutputGR <- reducedOlapGr
} else {
nhmmerOutputGR <- nhmmerOutputGRBeforeMerge
}
#####   Extract the DNA sequences of the hits and record in GRanges mcols   #####
## Load in R the DNA sequences that are queried for TALE CDS
subjectDNASequences <- Biostrings::readDNAStringSet(filepath = subjectFile)
names(subjectDNASequences) <- originalSeqlevels[match(names(subjectDNASequences), names(originalSeqlevels))]
## Extract the DNA sequences of the hits
hitSeqs <- BSgenome::getSeq(subjectDNASequences, nhmmerOutputGR)
S4Vectors::mcols(nhmmerOutputGR) %<>% cbind(
data.frame(
"seq" = as.character(hitSeqs),
"codon_count" = Biostrings::nchar(hitSeqs) %/% 3,
"frameshift_count" = Biostrings::nchar(hitSeqs) %% 3,
row.names = NULL,
check.rows = T)
)
arraysGR <- GenomicRanges::reduce(nhmmerOutputGR,
drop.empty.ranges=FALSE,
min.gapwidth= minGapWidth,
with.revmap=TRUE,
ignore.strand=FALSE)
revmap <- S4Vectors::mcols(arraysGR)$revmap  # an IntegerList
## Use the mapping from reduced to original ranges to group the original ranges by reduced range:
hitsByArraysLst <- BiocGenerics::relist(nhmmerOutputGR[unlist(revmap)], revmap)
names(hitsByArraysLst) <- paste("ROI", sprintf("%05.0f", 1:length(hitsByArraysLst)), sep = "_")
names(arraysGR) <- names(hitsByArraysLst)
# hitsByArraysLst <- BiocGenerics::sort(hitsByArraysLst) # just to make sure...
## Make sure that hits do not overlap for some weird reason
doHitsOverlap <- !GenomicRanges::isDisjoint(hitsByArraysLst)
if (any(doHitsOverlap)) {
warning("It appears that some hmmer hits actually overlap.\n It is thus possible that the inferred sequences of RVDs have artefactual insertions.\n")
warning(paste0("Please check the hits in the following RegionsOfInterest:", "\n",
paste(names(doHitsOverlap)[doHitsOverlap], collapse = "\n"), "\n")
)
}
#####   Storing all info about domain arrays in a central object   ####
stitchSeqs <- function(grl, seqType, sep = "-", onlyRepeats = FALSE) {
BiocGenerics::sapply(grl, function(x) {
if (onlyRepeats) {
gr <- BiocGenerics::subset(x = x, query_name == repeatDNAHMMName)
} else {
gr <- x
}
v <- as.character(S4Vectors::mcols(gr)[, seqType])
if (all(as.character(BiocGenerics::strand(gr)) == "+")) {
seq <- paste0(v, collapse = sep)
} else if (all(as.character(BiocGenerics::strand(gr)) == "-")) {
seq <- paste0(rev(v), collapse = sep)
} else {
stop("The current array has domains on different strands. Something is very wrong!")
}
}, simplify = TRUE, USE.NAMES = TRUE)
}
## Populate metadata about the elements of the list of arrays
S4Vectors::mcols(hitsByArraysLst) <- S4Vectors::DataFrame(
arrayID = names(hitsByArraysLst),
OriginalSubjectName = sapply(hitsByArraysLst,
function(x) unique(as.character(GenomicRanges::seqnames(x)))),
Start = BiocGenerics::start(arraysGR),
End = BiocGenerics::end(arraysGR),
Strand = BiocGenerics::strand(arraysGR),
NumberOfHits = S4Vectors::elementNROWS(hitsByArraysLst),
ArraySeq = BSgenome::getSeq(subjectDNASequences, arraysGR),
AllDomains = sapply(hitsByArraysLst,
function(x) {
all(
c(TALE_NtermDNAHMMName, repeatDNAHMMName,
TALE_CtermDNAHMMName) %in% x$query_name
)
}
)
mcols(hitsByArraysLst)
#### Correction ####
# correct tal arrays if requested
if (!talArrayCorrection) {
#str(S4Vectors::mcols(hitsByArraysLst))
#####   Detects longest ORF in (complete) arrays   #####
## Extract the genomic sequence of ("full length") arrays +- 5bp on the borders
## run systemPipeR::predORF()
## ask if the longest orf GRanges on the plus strand (perfectly) matches with the complete array GRanges
## Record this info in the arrayReport object
## Export the dna seq of the longest orf as the tal sequences
completeArraysGR <- arraysGR #subset(arraysGR, S4Vectors::mcols(hitsByArraysLst)$AllDomains) #
extdCompleteArraysGR <- GenomicRanges::resize(completeArraysGR,
width = GenomicRanges::width(completeArraysGR) + 200,
fix="start", ignore.strand=FALSE) %>%
GenomicRanges::resize(., width = GenomicRanges::width(.) + 3,
fix="end", ignore.strand=FALSE)
extdCompleteArraysSeqs <- BSgenome::getSeq(subjectDNASequences, extdCompleteArraysGR)
orfs <- systemPipeR::predORF(x = extdCompleteArraysSeqs,
n=1, type = "gr", mode = "ORF", strand = "sense")
fullTalCds <- BSgenome::getSeq(extdCompleteArraysSeqs, orfs)
names(fullTalCds) <- as.character(GenomicRanges::seqnames(orfs))
} else {
AAref <- Biostrings::readAAStringSet(refForTalArrayCorrection, seek.first.rec = TRUE, use.names = TRUE)
rawArraySeq <- mcols(hitsByArraysLst)$ArraySeq
ArrayCorrection <- DECIPHER::CorrectFrameshifts(rawArraySeq, AAref, type = "both", maxComparisons = length(AAref), frameShift = frameShiftCorrection)
fullTalCds <- ArrayCorrection$sequences
insertions_count <- correction_tible(ArrayCorrection$indels) %>% dplyr::group_by(Seq) %>% dplyr::count(variable, name = "corrected_ins_count") %>% dplyr::filter(variable == "insertions") %>% dplyr::select(-variable)
deletions_count <- correction_tible(ArrayCorrection$indels) %>% dplyr::group_by(Seq) %>% dplyr::count(variable, name = "corrected_dels_count") %>% dplyr::filter(variable == "deletions") %>% dplyr::select(-variable)
alignmentDir <- file.path(outputDir, "CorrectionAlignment")
dir.create(alignmentDir, showWarnings = F)
correctedTalCds <- fullTalCds[sapply(names(fullTalCds), function(n) n %in% c(insertions_count$Seq, deletions_count$Seq))]
for (n in names(correctedTalCds)) {
rawSeq <- rawArraySeq[n]
names(rawSeq) <- paste0("raw_", n)
correctedSeq <- correctedTalCds[n]
names(correctedSeq) <- paste0("corrected_", n)
seqToAlign <- c(rawSeq, correctedSeq)
alignedSeqs <- DECIPHER::AlignSeqs(seqToAlign)
DECIPHER::BrowseSeqs(alignedSeqs, htmlFile = file.path(alignmentDir, glue::glue("CorrectionAlignment_{n}.html")), openURL = F)
}
tmpAnnotaleDir <- tempfile(pattern = "temp_annotale_", tmpdir = outputDir)
dir.create(tmpAnnotaleDir)
seqsOfRVDs <- Biostrings::AAStringSet()
for (talOrfID in names(fullTalCds)) {
AnnotaleDir <- file.path(tmpAnnotaleDir, talOrfID)
dir.create(AnnotaleDir)
talCds <- fullTalCds[talOrfID]
correctedTalCdsFile <- file.path(AnnotaleDir, "putativeTalCds.fasta")
Biostrings::writeXStringSet(fullTalCds[talOrfID], correctedTalCdsFile)
# run annotale for tal arrays on tempdir
check <- try(analyzeAnnoTALE(correctedTalCdsFile, AnnotaleDir))
if (check == 0) {
annoTaleRVD <- file.path(AnnotaleDir, "Analyze/TALE_RVDs.fasta")
seqOfRVDs <- Biostrings::readAAStringSet(annoTaleRVD, seek.first.rec = T, use.names = T)
names(seqOfRVDs) <- talOrfID
seqsOfRVDs <- c(seqsOfRVDs, seqOfRVDs)
}
# setwd("/home/baotram/tal/xanthopore-scripts/tantale")
devtools::load_all()
tantale::tellTale2(subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/PXO86.fa",
outputDir = pxo86_correct,
taleArrayStartAnchorCode = "N-TERM",
taleArrayEndAnchorCode = "C-TERM",
appendExtremityCodes = TRUE,
rvdSep = " ",
talArrayCorrection = TRUE,
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz",
frameShiftCorrection = -11)
# setwd("/home/baotram/tal/xanthopore-scripts/tantale")
devtools::load_all()
tantale::tellTale2(subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/PXO86.fa",
outputDir = pxo86_correct,
taleArrayStartAnchorCode = "N-TERM",
taleArrayEndAnchorCode = "C-TERM",
appendExtremityCodes = TRUE,
rvdSep = " ",
talArrayCorrection = TRUE,
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz",
frameShiftCorrection = -11)
## Merge with arrays metadata in mcols(hitsByArraysLst)
moreInfo <- merge(
S4Vectors::mcols(hitsByArraysLst),
data.frame(arrayID = names(fullTalCds),
LongestOrfLength = Biostrings::nchar(fullTalCds),
OrfCovOverArrayLength = round(100 * Biostrings::nchar(fullTalCds)/GenomicRanges::width(completeArraysGR[names(fullTalCds)])),
LongestORFSeq = fullTalCds),
by = "arrayID", all.x = TRUE, sort = FALSE)
hitsByArraysLst
completeArraysGR
# setwd("/home/baotram/tal/xanthopore-scripts/tantale")
devtools::load_all()
tantale::tellTale2(subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/PXO86.fa",
outputDir = pxo86_correct,
taleArrayStartAnchorCode = "N-TERM",
taleArrayEndAnchorCode = "C-TERM",
appendExtremityCodes = TRUE,
rvdSep = " ",
talArrayCorrection = TRUE,
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz",
frameShiftCorrection = -11)
# setwd("/home/baotram/tal/xanthopore-scripts/tantale")
devtools::load_all()
bai311_correct <- file.path(testdir, "bai3-1-1_correct")
dir.create(bai311_correct)
tantale::tellTale2(subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/BAI3-1-1.fa",
outputDir = bai311_correct,
taleArrayStartAnchorCode = "N-TERM",
taleArrayEndAnchorCode = "C-TERM",
appendExtremityCodes = FALSE,
rvdSep = "-",
talArrayCorrection = TRUE,
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz",
frameShiftCorrection = -11)
hitsByArraysLst
hitsByArraysLst[[1]]
# setwd("/home/baotram/tal/xanthopore-scripts/tantale")
devtools::load_all()
tantale::tellTale2(subjectFile = "/home/baotram/tal/xanthopore-scripts/tantale/test/telltale_vs_annotale/genomes/BAI3-1-1.fa",
outputDir = bai311_correct,
taleArrayStartAnchorCode = "N-TERM",
taleArrayEndAnchorCode = "C-TERM",
appendExtremityCodes = FALSE,
rvdSep = "-",
talArrayCorrection = TRUE,
refForTalArrayCorrection = "/home/baotram/tal/xanthopore-scripts/talomes_analysis/correctframshift_ref/AA_ref.fa.gz",
frameShiftCorrection = -11)
